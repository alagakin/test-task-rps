## Реализация Sliding Window Count и Sliding Window Log

Код написан из предпосылки, что ограничение на количество запросов накладывается на клиент, а не сервер.

Ограничения реализованы на произвольный временной интервал, не обязательно 1 секунда

Оба алгоритма я реализовал используя паттерн Strategy, что позволяет мне без труда заменять их при необхомости, а также не создает зависимости между ними и клиентом.

### Client
Хранит данные в FIFO очереди. Метод send_next пытается отправить запрос на сервер.

### Server
Умеет получать запросы. С заданной вероятностью либо принимает, либо отклоняет запрос.

### SlidingWindowCount
Я нахожу эту стратегию более подходящей для данной задачи. 

Во-первых она использует меньше памяти для хранения истории запросов.
Во-вторых она не требует останавливаться при постоянной отправке запросов

### SlidingWindowLog
Использует больше памяти, чем SlidingWindowCount, т.к. требует поддержание лога
В моем тестовом примере из-за возможности отправлять запросы очень часто (единственное ограничение - скорость выполнения цикла) - пришлось реализовать метод cool_down внутри самой стратегии. Он вызывается при переполнении лога.

### tests
Самый интересный - test_rate_does_not_exceed - находит минимальную разницу между двумя соседними интервалами и проверяет то, что она не превышает rate больше чем на заданную tolerance (10%)
